<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"></head><body>
<h1>Findeco<a href="#WorkingTitle">*</a> API</h1>
<h3>General Information</h3>
The Findeco<a href="#WorkingTitle">*</a> API allows for access to the full scope of functions and data available to the original Findeco<a href="#WorkingTitle">*</a> Client.<br>
The general API call is setup like this: .json_FUNCTION/DATA<br>
In return you get a JSON response from the server.
<br>
<br>
<h3>Functions</h3>
<br>
<b><a name="FunctionLoadGraphData">Function::loadGraphData</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadGraphData/graphDataType/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValueGraphDataType">(String) graphDataType</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the requested graph data of the given path to a StructureNode (see <a href="#ValuePath">Value::Path</a>).</td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadGraphDataResponse">JSON::loadGraphDataResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadIndex">Function::loadIndex</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadIndex/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the index of the given path to a StructureNode (see <a href="#ValuePath">Value::Path</a>). </td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadIndexResponse">JSON::loadIndexResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadArgumentIndex">Function::loadArgumentIndex</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadIndex/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the argument index for the given path to a StructureNode (see <a href="#ValuePath">Value::Path</a>).</td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadIndexResponse">JSON::loadArgumentIndexResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadNode">Function::loadNode</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadNode/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the fullTitle, index, and some additional information of the given path to a StructureNode (see <a href="#ValuePath">Value::Path</a>)</td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadNodeResponse">JSON::loadNodeResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadMicroblogging">Function::loadMicroblogging</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadMicroblogging/selectID/microbloggingLoadType/[path|displayName]</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueDisplayName">(String) displayName</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueSelectID">(Integer) selectID</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueMicrobloggingLoadType">(String) microbloggingLoadType</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the microblogging entrys of the given path to a StructureNode or an Argument (see <a href="#ValuePath">Value::Path</a>). If the path does not match a StructureNode or an Argument it is interpreted as <a href="#ValueDisplayName">Value::displayName</a>. </td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadMicrobloggingResponse">JSON::loadMicrobloggingResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadText">Function::loadText</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadText/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the textview of the given path to a StructureNode or an Argument(see <a href="#ValuePath">Value::Path</a>).</td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadTextResponse">JSON::loadTextResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadUserInfo">Function::loadUserInfo</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadUserInfo/displayName</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValueDisplayName">(String) displayName</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads infos to the requested user. </td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadUserInfoResponse">JSON::loadUserInfoResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLoadUserSettings">Function::loadUserSettings</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_loadUserSettings</td></tr>
    <tr><td>GET Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Loads the settings for the currently logged in user. </td></tr>
    <tr><td>Return:</td><td><a href="#JSONloadUserSettingsResponse">JSON::loadUserSettingsResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLogin">Function::login</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_login</td></tr>
    <tr><td>GET Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>POST Parameters:</td><td><a href="#ValueUsername">(String) username</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValuePassword">(String) password</a></td></tr>
    <tr><td>Description:</td><td>Login function to get access to use of the API.</td></tr>
    <tr><td>Return:</td><td><a href="#JSONloginResponse">JSON::loginResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionLogout">Function::logout</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_logout</td></tr>
    <tr><td>GET Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Logout function.</td></tr>
    <tr><td>Return:</td><td><a href="#JSONlogoutResponse">JSON::logoutResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionSearch">Function::search</a></b>
<table><tbody>
<tr><td>Call Structure:</td><td>.json_search/searchField/searchString</td></tr>
<tr><td>GET Parameters:</td><td><a href="#ValueSearchField">(String) searchFields</a></td></tr>
<tr><td>&nbsp;</td><td>(String) searchString</td></tr>
<tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
<tr><td>Description:</td><td>Search for occurances of searchString in <a href="#ValueSearchField">searchFields</a>. searchFields can be a singe <a href="#ValueSearchField">searchField</a> or up to all three sparated by "_".</td></tr>
<tr><td>Return:</td><td><a href="#JSONsearchResponse">JSON::searchResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionMarkNode">Function::markNode</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_markNode/markType/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueMarkType">(String) markType</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Mark a StructureNode or an Argument (see <a href="#ValuePath">Value::Path</a>) according to <a href="#ValueMarkType">Value::markType</a>.</td></tr>
    <tr><td>Return:</td><td><a href="#JSONmarkNodeResponse">JSON::markNodeResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionStoreMicroblogPost">Function::storeMicroblogPost</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_storeMicroblogPost/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td><a href="#ValueMicroblogText">(String) microblogText</a></td></tr>
    <tr><td>Description:</td><td>Store a Microblogpost attached to a path to a StructureNode or an Argument (see <a href="#ValuePath">Value::Path</a>).</td></tr>
    <tr><td>Return:</td><td><a href="#JSONstoreMicroblogPostResponse">JSON::storeMicroblogPostResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionStoreMicroblogReference">Function::storeMicroblogReference</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_storeMicroblogReference/microblogID</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValueMicroblogID">(int) microblogID</a></td></tr>
    <tr><td>POST Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>Description:</td><td>Show the Microblogpost referenced by <a href="#ValueMicroblogID">Value::microblogID</a> as a post within the timeline of the loggedin user. The post does not get duplicated, if it is removed the reference will also vanish. </td></tr>
    <tr><td>Return:</td><td><a href="#JSONstoreMicroblogReferenceResponse">JSON::storeMicroblogReferenceResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<b><a name="FunctionStoreSettings">Function::storeSettings</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_storeSettings</td></tr>
    <tr><td>GET Parameters:</td><td>&nbsp;</td></tr>
    <tr><td>POST Parameters:</td><td><a href="#ValueDisplayName">(String) displayName</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueDescription">(String) description</a></td></tr>
    <tr><td>Description:</td><td>Store settings for the current user.</td></tr>
    <tr><td>Return:</td><td><a href="#JSONstoreSettingsResponse">JSON::storeSettingsResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

Store a new Textnode or Argument in the hierarchy attached to a StructureNode (see <a href="#ValuePath">Value::Path</a>).
<br>
<b><a name="FunctionStoreText">Function::storeText</a></b>
<table><tbody>
    <tr><td>Call Structure:</td><td>.json_storeText/path</td></tr>
    <tr><td>GET Parameters:</td><td><a href="#ValuePath">(String) path</a></td></tr>
    <tr><td>POST Parameters:</td><td><a href="#ValueWikiText">(String) wikiText</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueArgumentType">(String) argumentType</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueWikiTextAlternative">(String) wikiTextAlternative</a></td></tr>
    <tr><td>Description:</td><td>If only wikiText is given, then add a slot(Title) to current node (actually this will create a copy of the current node with the additional slot) and add the new structure node from wikiText as a child.</td></tr>
    <tr><td>&nbsp;</td><td>If only wikiTextAlternative is given, then create a new structure node from wikiTextAlternative and store it as an alternative to the current node (at path) </td></tr>
    <tr><td>&nbsp;</td><td>If wikiText and argumentType are given, then store a new argument concerning path</td></tr>
    <tr><td>&nbsp;</td><td>If wikiText, argumentType, and wikiTextAlternative are given, then store a new derivate of the source node (at path) as a sibling and add argument with wikiText as derivationArgument to source node</td></tr>
    <tr><td>Return:</td><td><a href="#JSONstoreTextResponse">JSON::storeTextResponse</a> or <a href="#JSONerrorResponse">JSON::errorResponse</a></td></tr>
</tbody></table>

<br>
<br>
<h3>Variable Values</h3>

<br>
<b><a name="ValueArgumentDenominator">Value::argumentDenominator</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>argumentDenominator</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The denominator for arguments to decide wether they are pro, contra or neutral arguments. The "all" denominator ignores any <a href="#ValueIndex">Value::index</a> after it. </td></tr>
    <tr><td>Supported Values:</td><td>[pro|con|neut|all]</td></tr>
</tbody></table>

<br>
<b><a name="ValueArgumentType">Value::argumentType</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>argumentType</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The type for arguments to decide wether they are pro, contra or neutral arguments. This parameter should only be set if an argument has been posted. To post a text leave it unset. </td></tr>
    <tr><td>Supported Values:</td><td>[pro|con|neut]</td></tr>
</tbody></table>

<br>
<b><a name="ValueDescription">Value::description</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>description</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The description the user has setup. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueDisplayName">Value::displayName</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>displayName</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The name the user has setup to be his displayed name. </td></tr>
    <tr><td>Default:</td><td>Anonymous</td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueErrorMessage">Value::errorMessage</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>errorMessage</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The message of the error the last call has thrown. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueErrorTitle">Value::errorTitle</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>errorTitle</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The title of the error the last call has thrown. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueFollows">Value::follows</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>follows</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The number of followers for a node. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueSpamFlags">Value::spamFlags</a></b>
<table><tbody>
<tr><td>Parametername:</td><td>spamFlags</td></tr>
<tr><td>Type:</td><td>Integer</td></tr>
<tr><td>Description:</td><td>The number of spam flags a node has. </td></tr>
<tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueFullTitle">Value::fullTitle</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>fullTitle</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The full title of a node in the hierarchy, these are set by the user. </td></tr>
    <tr><td>Supported Values:</td><td>Any string.</td></tr>
</tbody></table>

<br>
<b><a name="ValueGraphDataType">Value::graphDataType</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>graphDataType</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The requested type of graph data. </td></tr>
    <tr><td>Supported Values:</td><td>[default|full|withSpam]</td></tr>
</tbody></table>

<br>
<b><a name="ValueIndex">Value::index</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>index</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The index of a node in the hierarchy, most important in case of conflicting nodes to the same <a href="#ValueShortTitle">Value::shortTitle</a>. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueIsFollowing">Value::isFollowing</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>isFollowing</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>Shows wether the currently logged in user is following a node. 0 for not following, 1 for transitive following (user is following a node above this node), 2 for following.</td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueIsFlagging">Value::isFlagging</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>isFlagging</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>Shows wether the currently logged in user is flagging this node as Spam. 0 for not flagging, 1 for flagging.</td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueLoadArgument">Value::loadArgument</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>loadArgument</td></tr>
    <tr><td>Type:</td><td>Boolean</td></tr>
    <tr><td>Description:</td><td>Flag to decide wether to load Argument or StructureNode lists for <a href="#FunctionLoadIndex">Function::loadIndex</a>. </td></tr>
    <tr><td>Supported Values:</td><td>True or False</td></tr>
    <tr><td>Default:</td><td>False</td></tr>
</tbody></table>

<br>
<b><a name="ValueMarkType">Value::markType</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>markType</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The type of marking to associate with the given Node. </td></tr>
    <tr><td>Supported Values:</td><td>[spam|notspam|follow|unfollow]</td></tr>
</tbody></table>

<br>
<b><a name="ValueSearchField">Value::searchField</a></b>
<table><tbody>
<tr><td>Parametername:</td><td>searchField</td></tr>
<tr><td>Type:</td><td>String</td></tr>
<tr><td>Description:</td><td>The list of fields where to search. This can be related to users (names, descriptions, etc), content (proposals, arguments) and/or microblogging.</td></tr>
<tr><td>Supported Values:</td><td>[user|content|microblogging]</td></tr>
</tbody></table>

<br>
<b><a name="ValueMicrobloggingLoadType">Value::microbloggingLoadType</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>microbloggingLoadType</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The requested load type for loadMicroblogging. </td></tr>
    <tr><td>Supported Values:</td><td>[newer|older]</td></tr>
</tbody></table>

<br>
<b><a name="ValueMicroblogID">Value::microblogID</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>microblogID</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The ID of a microblog post.</td></tr>
    <tr><td>Supported Values:</td><td>Any ID leading to an existing microblogpost in the db.</td></tr>
</tbody></table>

<br>
<b><a name="ValueMicroblogText">Value::microblogText</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>microblogText</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The text of a microblog post.</td></tr>
    <tr><td>Supported Values:</td><td>Any unformatted String.</td></tr>
</tbody></table>

<br>
<b><a name="ValueMicroblogTime">Value::microblogTime</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>microblogTime</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The unix timestamp of a microblog post.</td></tr>
    <tr><td>Supported Values:</td><td>Any unix timestamp.</td></tr>
</tbody></table>

<br>
<b><a name="ValueNewFollows">Value::newFollows</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>newFollows</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The number of new followers for a node. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValuePassword">Value::password</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>password</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The password to login for use of the API.</td></tr>
    <tr><td>Supported Values:</td><td>Any password that is registered in the database and matches the selected user.</td></tr>
</tbody></table>

<br>
<b><a name="ValuePath">Value::path</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>path</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The path to any node in the hierarchy. Paths are built out of <a href="#ValueShortTitle">Value::shortTitle</a> and <a href="#ValueIndex">Value::index</a>
 by concatenating them with a ".", these individual parts of the path 
are concatenated by "/" but any path may also be trailed by a set of <a href="#ValueArgumentDenominator">Value::argumentDenominator</a> with or without a <a href="#ValueIndex">Value::index</a> that is appended using a "." behind the <a href="#ValueIndex">Value::index</a> of the respective node.</td></tr>
    <tr><td>Supported Values:</td><td>Any path leading to an existing node in the database. Depending on the function this may be a StructureNode<!--, an ArgumentCategory !--> or an Argument. <br>Examples:
StructureNode: "top.1/subtop.2", "top.1/subtop.2/subsubtop", "top.1/subtop.2/subsubtop.3"<br>
<!--ArgumentCategory: "top.1/subtop.2/subsubtop.3.neut", "top.1/subtop.2/subsubtop.3.all"<br>!-->
Argument: "top.1/subtop.2/subsubtop.3.neut.1", "top.1/subtop.2/subsubtop.3.pro.3"</td></tr>
</tbody></table>

<br>
<b><a name="ValueSelectID">Value::selectID</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>selectID</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The reference ID of an allready loaded microblogging entry. Usually the first loaded for <a href="#ValueMicrobloggingLoadType">Value::microbloggingLoadType</a> "older" and the last for "newer". This value can be left empty to load the newest microblogentries
available. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueShortTitle">Value::shortTitle</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>shortTitle</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The short title of a node in the hierarchy, these are generated out of <a href="#ValueFullTitle">Value::fullTitle</a> of the respective or a previous conflicting node. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueSuccess">Value::success</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>success</td></tr>
    <tr><td>Type:</td><td>Boolean</td></tr>
    <tr><td>Description:</td><td>The information wether the last action was successfull or not.</td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueUsername">Value::username</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>username</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>The username to login for use of the API.</td></tr>
    <tr><td>Supported Values:</td><td>Any user that is registered in the database.</td></tr>
</tbody></table>

<br>
<b><a name="ValueUserRights">Value::userRights</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>userRights</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The userRights number. Following unix-filepermissions: 1 = allowed to write new posts, 2 = allowed to vote, 4 = moderator, and any summary combination thereof.</td></tr>
    <tr><td>Supported Values:</td><td>Any sum of valid permissions.</td></tr>
</tbody></table>

<br>
<b><a name="ValueUnFollows">Value::unFollows</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>unFollows</td></tr>
    <tr><td>Type:</td><td>Integer</td></tr>
    <tr><td>Description:</td><td>The number of followers that unfollowed a node. </td></tr>
    <tr><td>Supported Values:</td><td>Output only.</td></tr>
</tbody></table>

<br>
<b><a name="ValueWikiText">Value::wikiText</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>wikiText</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>Wikisyntax formatted text. </td></tr>
    <tr><td>Supported Values:</td><td>Any wikisyntax compatible text.</td></tr>
</tbody></table>

<br>
<b><a name="ValueWikiTextAlternative">Value::wikiTextAlternative</a></b>
<table><tbody>
    <tr><td>Parametername:</td><td>wikiTextAlternative</td></tr>
    <tr><td>Type:</td><td>String</td></tr>
    <tr><td>Description:</td><td>Wikisyntax formatted text that is used as an alternative proposition in case of posting a neutral or contrary argument. </td></tr>
    <tr><td>Supported Values:</td><td>Any wikisyntax compatible text.</td></tr>
</tbody></table>

<br>
<br>
<h3>Responses</h3>

<br>
<b><a name="JSONauthorGroup">JSON::authorGroup</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuserInfo">JSON::userInfo</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple users.</td></tr>
</tbody></table>

<br>
<b><a name="JSONblockedUsers">JSON::blockedUsers</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuser">JSON::user</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple users.</td></tr>
</tbody></table>

<br>
<b><a name="JSONerrorResponse">JSON::errorResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValueErrorTitle">Value::errorTitle</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueErrorMessage">Value::errorMessage</a></td></tr>
    <tr><td>Comment:</td><td>The error to be displayed to the user.</td></tr>
</tbody></table>

<br>
<b><a name="JSONfollowees">JSON::followees</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuser">JSON::user</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple users.</td></tr>
</tbody></table>

<br>
<b><a name="JSONfollowers">JSON::followers</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuser">JSON::user</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple users.</td></tr>
</tbody></table>

<br>
<b><a name="JSONgraphDataChildren">JSON::graphDataChildren</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONgraphDataNode">JSON::graphDataNode</a></td></tr>
    <tr><td>Comment:</td><td>Childnodes to a loadGraphData Request. May contain multiple nodes.</td></tr>
</tbody></table>

<br>
<b><a name="JSONgraphDataRelated">JSON::graphDataRelated</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONgraphDataNode">JSON::graphDataNode</a></td></tr>
    <tr><td>Comment:</td><td>Related nodes to a loadGraphData Request. May contain multiple or no nodes.</td></tr>
</tbody></table>

<br>
<b><a name="JSONgraphDataNode">JSON::graphDataNode</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValuePath">Value::path</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONauthorGroup">JSON::authorGroup</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueFollows">Value::follows</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueSpamFlags">Value::spamFlags</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueUnFollows">Value::unFollows</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueNewFollows">Value::newFollows</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONoriginGroup">JSON::originGroup</a></td></tr>
    <tr><td>Comment:</td><td>Graphdata shows the rate of follows to unfollows to new follows in order to allow to assess the Structurenode it is related to. All Structurenodes (except for the root node) are part of a Slot (a point in the hierarchy with one or more conflicting Structurenodes) so there can be one or more graphDataNode per resultset. </td></tr>
</tbody></table>

<br>
<b><a name="JSONindexList">JSON::indexList</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONindexNode">JSON::indexNode</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple or no nodes.</td></tr>
</tbody></table>

<br>
<b><a name="JSONindexNode">JSON::indexNode</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValueShortTitle">Value::shortTitle</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueArgumentDenominator">Value::argumentDenominator</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueFullTitle">Value::fullTitle</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIndex">Value::index</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONauthorGroup">JSON::authorGroup</a></td></tr>
    <tr><td>Comment:</td><td>This element contains either <a href="#ValueShortTitle">Value::shortTitle</a> or <a href="#ValueArgumentDenominator">Value::argumentDenominator</a> depending on wether it is a StructureNode or an Argument. See <a href="#ValuePath">Value::path</a> for further information. </td></tr>
</tbody></table>

<br>
<b><a name="JSONloadGraphDataResponse">JSON::loadGraphDataResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONgraphDataChildren">JSON::graphDataChildren</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONgraphDataRelated">JSON::graphDataRelated</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONloadIndexResponse">JSON::loadIndexResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONindexNode">JSON::indexNode</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple nodes.</td></tr>
    <tr><td>Example:</td><td>{"loadIndexResponse":[{"shortTitle":"subsubtopic","index":1,"fullTitle":"This is a subsubtopic!","authorGroup":["author1","author2"]},{"shortTitle":"subsubtopic2","index":1,"fullTitle":"This is a second subsubtopic!","authorGroup":["author1","author3"]}]}</td></tr>
</tbody></table>

<br>
<b><a name="JSONloadArgumentIndexResponse">JSON::loadArgumentIndexResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONindexNode">JSON::indexNode</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple nodes.</td></tr>
</tbody></table>

<br>
<b><a name="JSONloadNodeResponse">JSON::JSONloadNodeResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONindexList">JSON::indexList</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueFullTitle">Value::fullTitle</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueWikiText">Value::wikiText</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIsFollowing">Value::isFollowing</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIsFlagging">Value::isFlagging</a></td></tr>
    <tr><td>Comment: Contains only the wikiText for this node, and it is without heading.</td><td></td></tr>
</tbody></table>


<br>
<b><a name="JSONloadMicrobloggingResponse">JSON::loadMicrobloggingResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONmicroblogNode">JSON::microblogNode</a></td></tr>
    <tr><td>Comment:</td><td>May contain multiple nodes.</td></tr>
</tbody></table>

<br>
<b><a name="JSONloadTextResponse">JSON::loadTextResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONparagraph">JSON::paragraphs</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIsFollowing">Value::isFollowing</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIsFlagging">Value::isFlagging</a></td></tr>
    <tr><td>Example:</td><td>{"loadTextResponse":{"paragraphs":[{"wikiText":"= This is a subsubtopic! =\r\nBlablabla.\r\nBlablubblubb.","path":"topic.1\/subtopic.1\/subsubtopic.1","isFollowing":1,"authorGroup":["author1","author2"]},{"wikiText":"= This is a second subsubtopic! =\r\nBlablabla.\r\nBlablubblubb.","path":"topic.1\/subtopic.1\/subsubtopic2.1","isFollowing":1,"authorGroup":["author1","author3"]}],"isFollowing":1}}</td></tr>
</tbody></table>

<br>
<b><a name="JSONloadUserInfoResponse">JSON::loadUserInfoResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuserInfo">JSON::userInfo</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONloadUserSettingsResponse">JSON::loadUserSettingsResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuserSettings">JSON::userSettings</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONuserInfo">JSON::userInfo</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONloginResponse">JSON::loginResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONuserSettings">JSON::userSettings</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONuserInfo">JSON::userInfo</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONlogoutResponse">JSON::logoutResponse</a></b>
<table><tbody>
    <tr><td>Comment:</td><td>The logoutResponse is always empty, or is it? </td></tr>
</tbody></table>

<br>
<b><a name="JSONmarkNodeResponse">JSON::markNodeResponse</a></b>
<table><tbody>
    <tr><td>Comment:</td><td>The markNodeResponse is always empty. </td></tr>
</tbody></table>

<br>
<b><a name="JSONsearchResponse">JSON::searchResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONsearchResponseList">JSON::searchResponseList</a></td></tr>
    <tr><td>Comment:</td><td>Contains one or more lists of search results (format of ).</td></tr>
</tbody></table>

<br>
<b><a name="JSONsearchResponseList">JSON::searchResponseList</a></b>
<table><tbody>
<tr><td>Content:</td><td><a href="#ValueSearchField">Value::searchField</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#JSONsearchEntry">JSON::searchEntries</a></td></tr>
<tr><td>Comment:</td><td>Contains a list of search entries for the <a href="#>ValueSearchField">searchField</a>.</td></tr>
</tbody></table>

<br>
<b><a name="JSONsearchEntry">JSON::searchEntry</a></b>
<table><tbody>
<tr><td>Content:</td><td>Value::url</td></tr>
<tr><td>&nbsp;</td><td>Value::snippet</td></tr>
<tr><td>Comment:</td><td>Contains a url and a snippet.</td></tr>
</tbody></table>

<br>
<b><a name="JSONmicroblogNode">JSON::microblogNode</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValueMicroblogText">Value::microblogText</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONauthorGroup">JSON::authorGroup</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueMicroblogTime">Value::microblogTime</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueMicroblogID">Value::microblogID</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONoriginGroup">JSON::originGroup</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValuePath">Value::path</a></td></tr>
    <tr><td>Comment:</td><td>This element may or may not contain one or more <a href="#ValuePath">Value::path</a> since this value is only present if the node it is part of is a direct part of the currently targetted slot.<br>If the node is an external origin instead, or the resultset was empty, no value will be present. </td></tr>
</tbody></table>

<br>
<b><a name="JSONparagraph">JSON::paragraphs</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONtextNode">JSON::textNode</a></td></tr>
    <tr><td>Comment:</td><td>Contains one or more textnodes.</td></tr>
</tbody></table>

<br>
<b><a name="JSONstoreMicroblogPostResponse">JSON::storeMicroblogPostResponse</a></b>
<table><tbody>
    <tr><td>Comment:</td><td>The storeMicroblogPostResponse is always empty. </td></tr>
</tbody></table>

<br>
<b><a name="JSONstoreMicroblogReferenceResponse">JSON::storeMicroblogReferenceResponse</a></b>
<table><tbody>
    <tr><td>Comment:</td><td>The storeMicroblogReferenceResponse is always empty. </td></tr>
</tbody></table>

<br>
<b><a name="JSONstoreSettingsResponse">JSON::storeSettingsResponse</a></b>
<table><tbody>
    <tr><td>Comment:</td><td>The storeSettingsResponse is always empty. </td></tr>
</tbody></table>

<br>
<b><a name="JSONstoreTextResponse">JSON::storeTextResponse</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValuePath">Value::path</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONtextNode">JSON::textNode</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValueWikiText">Value::wikiText</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValuePath">Value::path</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIsFollowing">Value::isFollowing</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueIsFlagging">Value::isFlagging</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONauthorGroup">JSON::authorGroup</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONuser">JSON::user</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValueDisplayName">Value::displayName</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONuserInfo">JSON::userInfo</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#ValueDisplayName">Value::displayName</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueDescription">Value::description</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONfollowees">JSON::followees</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#JSONfollowers">JSON::followers</a></td></tr>
</tbody></table>

<br>
<b><a name="JSONuserSettings">JSON::userSettings</a></b>
<table><tbody>
    <tr><td>Content:</td><td><a href="#JSONblockedUsers">JSON::blockedUsers</a></td></tr>
    <tr><td>&nbsp;</td><td><a href="#ValueUserRights">Value::userRights</a></td></tr>
</tbody></table>
<br>
<br>
<b><a name="WorkingTitle">Findeco is a work in progress and this API is subject to immediate change without notice.</a></b>
<div style="height:100%;margin-top:-10px;"></div>

</body></html>